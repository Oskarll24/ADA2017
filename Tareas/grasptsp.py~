import graph
import random
import TSPproblem

def graspTSP(probgraph, iters, alpha):
    sa = (None, 0)
    bs, bv = sa
    tspp = TSPproblem.TSPProblem(graph = probgraph)
    sl = []
    print(tspp.graph)
    for i in range(iters):
        so = greedyconstructive(tspp, alpha)
        ls = localsearch(tspp,so)
        av = prob.evaluate(ls)
        if be < ae:
            bs = ls
            bv = av
            fi = i
        sl.append((i, ls,ae))
        #print(so, ae, ls,be)
    return bs, be, fi, sl

def greedyconstructive(prob, alpha):
    path = []
    vl = list(prob.graph.vertices.keys())
    elem = random.choice(vl)
    si = elem
    #pendiente
    pl ={elem,0}
    vl.remove(elem)
    while len(vl)>0:
        print(prob.graph[elem].neighbors.items(), pl)
        nl = list(set(prob.graph[elem].neighbors.items()) - pl)
        if len(nl) == 0:
            break
        onl = sorted(nl, key=lambda x:x[1])
        lim = round(alpha*len(onl)) if round(alpha*len(onl)) > 1 else 1
        rcl = onl[0:lim]
        ce = random.choice(rcl)
        print (nl, elem, ce[0], ce[1])
        tup = (elem, ce[0], ce[1])
        path.append(tup)
        elem = ce[0]
        pl.add(ce)
        vl.remove(ce[0])
    if len(path) == len(prob.graph):
        path.append((elem, si, prob.graph[elem].neighbors[si]))
    return path
    
def localsearch(prob, so):
    
    return so

